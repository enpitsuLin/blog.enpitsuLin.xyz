---
import { toHtml } from 'hast-util-to-html';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import remarkCodeTitles from 'remark-flexible-code-titles';
import rehypePrismDiff from 'rehype-prism-diff';
import rehypePrismPlus from 'rehype-prism-plus';
import rehypeSlug from 'rehype-slug';
import rehypeRewrite from 'rehype-rewrite';
import remarkGfm from 'remark-gfm';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import { unified } from 'unified';
import { VFile } from 'vfile';
interface Props {
  content: string;
}
const { content } = Astro.props;
function mdToHtml(markdown: string) {
  const processor = unified()
    .use(remarkParse)
    .use(remarkGfm)
    .use(remarkCodeTitles, {
      title: false,
      containerProperties: (lang, title) => ({
        ['data-language']: lang,
        ['data-title']: title
      })
    })
    .use(remarkRehype, { allowDangerousHtml: true })
    .use(rehypeSlug)
    .use(rehypeRewrite, {
      selector: 'img',
      rewrite: (node) => {
        if (node.type === 'element' && node.tagName === 'img') {
          node.properties = Object.assign(node.properties ?? {}, {
            'data-zoomable': true
          });
        }
      }
    })
    .use(rehypePrismPlus, { ignoreMissing: true })
    .use(rehypePrismDiff)
    .use(rehypeAutolinkHeadings, { properties: { className: ['anchor'] } });

  const file = new VFile();

  file.value = markdown;

  const hastNode = processor.runSync(processor.parse(file), file);
  if (hastNode.type !== 'root') {
    throw new TypeError('Expected a `root` node');
  }

  return toHtml(hastNode);
}
const html = mdToHtml(content);
---

<>
  {html ? <Fragment set:html={html} /> : <slot />}
</>
